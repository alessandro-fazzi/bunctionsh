
# This code was auto generated by with these options:
# http://andrewray.me/bash-prompt-builder/index.html#git=1&color-git=3&git-prefix=1&color-git-prefix=3&git-ahead=1&color-git-ahead=6b&git-modified=1&color-git-modified=3&color-git-conflicted=1&color-git-revno=3&color-git-bisect=5&color-option-submodule=5&color-git-ontag=3&hg=1&color-hg=5&hg-prefix=1&color-hg-prefix=5&hg-modified=1&color-hg-modified=5&hg-conflicted=1&color-hg-conflicted=1&hg-revno=1&color-hg-revno=5&hg-bisect=1&color-hg-bisect=3&hg-patches=1&color-hg-patches=3&svn=1&color-svn=6&svn-modified=1&color-svn-modified=6&svn-revno=1&color-svn-revno=6&option-modified=%E2%96%B3&option-conflict=%E2%98%A2&color-option-conflict=3&max-conflicted-files=2&option-nobranch=no%20branch!&color-option-nobranch=1&bisecting-text=bisecting&submodule-text=%5Bsubmodule%5D%20
# then was hacked by PioneerSkies, because it was not working for me (Ubuntu12.10) and with some power-ups ;)
# * corrected a bug in a "grep"...don't remember exactly where :P
# * only git maintained
# * wrapped all the code inside a function so that it is READEABLE, no more
#   YO DAWG escapes and the resulting function is exportable to any PS1
#   constructor inside your dotfiles.

MAX_CONFLICTED_FILES=2
DELTA_CHAR="△"
CONFLICT_CHAR="☢"
BISECTING_TEXT="bisecting"
NOBRANCH_TEXT="no branch!"
REBASE_TEXT="✂ ʀebase"
SUBMODULE_TEXT=""


_git_dir=""
_git_svn_dir=""
function _git_check {
    _git_dir=`git rev-parse --show-toplevel 2> /dev/null`
    if [[ $_git_dir == "" ]]; then
        return 1
    else
        _gsvn_check=`cd $_git_dir; ls .git/svn/.metadata 2> /dev/null`

        if [[ ! -z $_gsvn_check ]]; then
            _git_svn_dir=$_git_dir
        fi
        return 0
    fi
}

function is_submodule() {
    local parent_git=`cd "$_git_dir/.." && git rev-parse --show-toplevel 2> /dev/null`
    if [[ -n $parent_git ]]; then
        local submodules=`cd "$parent_git" && git submodule --quiet foreach 'echo $path'`
        for line in $submodules; do
            cd "$parent_git/$line"
            if [[ `pwd` = $_git_dir ]]; then return 0; fi
        done
    fi
    return 1
}

function psgit_function() {
    # Figure out what repo we are in
    _git_check

    # Build the prompt!
    prompt=""

    # If we are in git ...
    if [ -n "$_git_dir" ]; then
        # find current branch
        gitBranch=$(git symbolic-ref HEAD 2> /dev/null)
        gitStatus=`git status`

        # Figure out if we are rebasing
        if [[ -d "$_git_dir/.git/rebase-apply" || -d "$_git_dir/.git/rebase-merge" ]]; then
            is_rebase=1
        fi

        # Figure out current branch, or if we are bisecting, or lost in space
        bisecting=""
        if [ -z "$gitBranch" ]; then
            if [ -n "$is_rebase" ]; then
                rebase_prompt=" $COLOR_LIGHT_CYAN"
                rebase_prompt=$rebase_prompt"`tput sc`  `tput rc`$REBASE_TEXT "
                rebase_prompt=$rebase_prompt"$COLOR_YELLOW"
            else
                gitBranch="${COLOR_RED}${NOBRANCH_TEXT}${COLOR_YELLOW}"
            fi
        fi
        gitBranch=${gitBranch#refs/heads/}
        #: git-svn
        if [ -z "$bisect" ]; then
            if [ -n "$_git_svn_dir" ]; then
                gitBranch="${COLOR_DARK_BLUE}git-svn${COLOR_YELLOW} $gitBranch"
            fi
        fi

            
        # if [ -z "$is_rebase" ]; then
            # changed *tracked* files in local directory?
            gitChange=$(echo $gitStatus | egrep 'modified:|deleted:|new file:')
            if [ -n "$gitChange" ]; then
                gitChange="$COLOR_YELLOW `tput sc`  `tput rc`$DELTA_CHAR "
                gitBranch="$COLOR_YELLOW $gitBranch"
            else
                gitUntracked=$(echo $gitStatus | egrep 'Untracked files:')
                if [ -n "$gitUntracked" ]; then
                    gitChange="$COLOR_YELLOW `tput sc`  `tput rc`"
                    gitBranch="$COLOR_YELLOW $gitBranch"
                fi
            fi
        # fi

            # output the branch and changed character if present
            prompt="$prompt$COLOR_GREEN ("

            if is_submodule; then
                prompt="${prompt}${COLOR_MAGENTA}${SUBMODULE_TEXT}${COLOR_YELLOW}"
            fi

            prefix="${COLOR_GREEN}git:$COLOR_GREEN"
            prompt="${prompt}${prefix}${gitBranch}${bisecting}"
            prompt="${prompt}${gitChange}$COLOR_GREEN)$COLOR_RESET"

            # How many local commits do you have ahead of origin?
            num=$(echo $gitStatus | grep "Your branch is ahead of" | awk '{split($0,a," "); print a[13];}') || return
            if [ -n "$num" ]; then
                prompt=$prompt"$COLOR_CYAN +$num"
            fi

        fi


    # Show conflicted files if any
    if [ -n "$files" ]; then
        prompt="${prompt}${COLOR_RED}(${COLOR_GREEN}"
        prompt="${prompt}`tput sc`  `tput rc`${COLOR_YELLOW}${CONFLICT_CHAR} "
        prompt="${prompt}${COLOR_RED} ${files})"
    fi

    echo -e $prompt

}

# End code auto generated by http://andrewray.me/bash-prompt-builder/index.html and hacked by PioneerSkies

# Now your PS1 will be overwritten by this one. It is splitted and commented,
# so easy to tweak it. If you prefere you can comment out PS1 starting lines
# and just put \$(psgit_function) in your pre-existent PS1 constructor: e.g.:

# In my .bashrc I have:
#
# PROMPT_INFO="${WHITE}[\A] ${GREEN}\u${WHITE}(${GREEN}\h${WHITE})${NC} ${BLUE}\w"
# PROMPT_RUBY="[\$(rvm-prompt)]"
# PROMPT_GIT="\$(psgit_function)"
# PROMPT_FOOTER="\n\$(is_vim_running && echo \"${RED}\" || echo \"${BLACK}\")↳ ${GREEN}\$ ${NC}"

# PS1="\n${PROMPT_INFO} ${PROMPT_RUBY} ${PROMPT_GIT} ${PROMPT_FOOTER}"


PS1="${debian_chroot:+($debian_chroot)}"                            #debian default
PS1="$PS1\[$COLOR_LIGHTCYAN\]\u"                                    #the user
PS1="$PS1\[$COLOR_WHITE\]@"
PS1="$PS1\[$COLOR_LIGHTCYAN\]\h"                                    #the host
PS1="$PS1\[$COLOR_WHITE\]:"
PS1="$PS1\[$COLOR_BLUE\]\w"                                         #current path
PS1="$PS1\[$COLOR_RESET\]\$(psgit_function)\[$COLOR_RESET\] "       #git status
PS1="$PS1\[$COLOR_LIGHTRED\]\\n\$"                                  #new line and $
PS1="$PS1\[$COLOR_RESET\] "                                         #reset at last
